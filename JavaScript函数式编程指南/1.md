# 第一章 走进函数式

## 前言：

当考虑应用设计时，你应该问问自己是否遵从了以下的设计原则：

  1. **可扩展性** --- 我是否需要不断地重构代码来支持额外的功能？
  2. **易模块化** --- 如果我更改了一个文件，另一个文件会不会受到影响？
  3. **可重用性** --- 是否有很多重复的代码？
  4. **可测性** --- 给这些函数添加单元测试是否让我纠结？
  5. **易推理性** --- 我写的代码是否非结构化严重并难以推理？

### 1.1 函数式编程有用吗？

  首先，JavaScript已经在 es6 中提供了一些原生的或基于 API 的函数式支持，例如：map，filter，reduce 等等。因此，行业对函数式编程技能的需求量很大，同时将在未来几年内不断增长。并且 JavaScript 可以用函数式风格写得更加高效。
  因为函数式编程是一种编写代码的方式，而不是一种框架或是工具，函数式的思维方式与面向对象的思维方式完全不同。摒弃旧习是最难的部分，对于一个有面向对象背景的人来说，将是一个巨大的编程范式转变。

### 1.2 什么是函数式编程？

  简单来说，函数式编程是一种强调以函数使用为主的软件开发风格。
  函数式编程的目标是使用函数来 **抽象作用在数据之上的控制流与操作** ，从而在系统中 **消除副作用并减少对状态的改变**。
  为了充分理解函数式编程，读者首先必须知道它所基于的一些基本概念：

- 声明式编程
- 纯函数
- 引用透明
- 不可变性

#### 1.2.1 函数式编程是声明式编程

  函数式编程属于 **声明式** 编程范式：这种范式会描述一系列的操作，但并不会暴露它们是如果实现的或是数据流如果穿过它们。目前，更加主流的是 **命令式** 的或 **过程式** 的编程范式。命令式编程将计算机程序视为一系列自上而下的断言，通过修改系统的各个状态来计算最终的结果。
  例如，假设你需要计算一个数组中所有数的平方，那命令式的程序应有如下的步骤：

  ```js
    var array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    for (let i = 0 ; i < array.length; i ++) {
      array[i] = Math.pow(array[i], 2);
    }
    array; // -> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
  ```

  命令式编程很具体地告诉计算机 **如何** 执行某个任务。
  而声明式编程是将程序的描述与求值分离开来的。它关注与如何用各种 **表达式** 来描述程序逻辑，而不一定要指明其控制流或状态的变化。
  上面的计算用声明式编程范式，同时结合 **lamda 表达式** 以及 **箭头函数** 的优势来将循环抽象成函数：

  ```js
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(num => Math.pow(num, 2));
    // -> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
  ```

#### 1.2.2 副作用带来的问题和纯函数

函数式编程基于一个前提，即使用纯函数构建具有不变性的程序。纯函数具有以下性质：

- 仅取决于提供的输入，而不依赖于任何函数求值期间或调用间隔时可能变化的隐藏状态和外部状态
- 不会造成超出其作用域的变化，例如修改全局对象或引用传递的参数

非纯函数会有以下的副作用：

- 改变一个全局变量、数据或数据结构
- 改变一个函数参数的原始值
- 处理用户输入
- 抛出一个异常，除非他又被当前函数捕获了
- 屏幕打印或记录日志
- 查询 HTML 文档、浏览器的 cookie 或访问数据库

函数式编程在实践上并不限制 **一切** 状态的改变。它只是提供了一个框架来帮助管理和减少可变状态，同时让你能够将纯函数从不纯的部分分离出来。

下面举一个例子，有一个短小的命令式程序，它能通过社会安全号码(SSN)找到一个同学的记录并渲染到浏览器中。

```js
function showStudent(ssn) {
  // 在对象储存中通过 SSN 查找学生。请假设这个操作现在是同步的，之后我会处理异步的情况。
  var student = db.get(ssn);
  if (student !== null) {
    // 读取函数外的 elementId 变量
    document.querySelector(`#${elementId}`).innerHTML = 
      `${student.ssn},
       ${student.firstname},
       ${student.lastname}`;
  } else {
    // 当学生信息错误时抛出异常
    throw new Error('student not found!');
  }
}

// 使用 SSN 号 444-44-4444 作为参数执行函数，结果会展示在页面上
showStudent('444-44-4444');
```

进一步分析这段代码，这个函数显然将一些副作用暴露到其作用域之外：

- 该函数为访问数据，与一个外部变量(db)进行了交互，因为该函数签名中并没有声明该参数。在任何一个时间点，这个引用可能为 null，或在调用间隔改变，从而导致完全不用的结果并破坏了程序的完整性。
- 全局变量 elementId 可能随时改变，难以控制。
- HTML 元素被直接修改了。HTML 文档(DOM)本身是一个可变的，共享的全局资源。
- 如果没有找到学生，该函数可能会抛出一个异常，这将导致整个程序的栈回退并突然结束。

一方面，上面的 showStudent 函数依赖了外部资源，使得代码很不灵活，很难维护并且难以测试。另一方面，使用纯函数，其函数签名对所描述的所有形参（输入集）都有明确的约定，使其更易于理解和使用。

再回到函数式的世界，目前可以改进以下两点：

- 将这个长函数分离成多个具有单一职责的短函数。
- 通过显式地将完成功能所需的依赖都定义为函数参数来减少副作用的数量。

首先分离屏幕显式与获取学生记录的行为。当然，与外部存储系统和 DOM 交互所造成的副作用是不可避免的，但至少可以通过将其从主逻辑中分离出来的方式使它们更易于管理。要做到这一点，需要引入一种常见的函数式编程技巧 --- **柯里化**。使用柯里化，可以允许部分地传递函数参数，以便将函数的参数减少为一个：

```js
// 函数 find 需要对象存储的引用和 ID 来查找学生
var find = curry(function(db, id) {
  var obj = db.get(id);
  if(obj === null) {
    throw new Error('Object not found!');
  }
  return obj;
});

// 将学生对象转换成用逗号分隔的字符串
var csv = function(student) {
  return `${student.ssn}, ${student.firstname}, ${student.lastname}`;
};

// 为了在屏幕上显示学生信息，这里需要 elementId 以及学生的数据
var append = curry(function(elementId, info) {
  document.querySelector(elementId).innerHTML = info;
});

var showStudent = run(
  append('#student-info'), // 部分设置 HTML 元素的 ID
  csv,
  find(db) // 部分设置查找对象为学生表
);

showStudent('444-44-4444');
```

尽管这个程序只有些许的改进，但是它开始展现出很多的优势：

- 它灵活了很多，因为现在有三个可以被重用的组件。
- 这种细粒度函数的重用是提高工作效率的一种手段，因为你可以大大减少需要主动维护的代码量。
- 声明式的代码风格提供了程序需要执行的那些高阶步骤的一个清晰视图，增强了代码的可读性。
- 更重要的是，与 HTML 对象的交互被移动到一个单独的函数中，将纯函数从不纯的行为中分离出来。柯里化以及如何管理纯与不纯的代码将在下面的文章中进一步解释。

#### 1.2.3 副作用带来的问题和纯函数
