# 第一章 走进函数式

## 前言：

当考虑应用设计时，你应该问问自己是否遵从了以下的设计原则：

  1. **可扩展性** --- 我是否需要不断地重构代码来支持额外的功能？
  2. **易模块化** --- 如果我更改了一个文件，另一个文件会不会受到影响？
  3. **可重用性** --- 是否有很多重复的代码？
  4. **可测性** --- 给这些函数添加单元测试是否让我纠结？
  5. **易推理性** --- 我写的代码是否非结构化严重并难以推理？

### 1.1 函数式编程有用吗？

  首先，JavaScript已经在 es6 中提供了一些原生的或基于 API 的函数式支持，例如：map，filter，reduce 等等。因此，行业对函数式编程技能的需求量很大，同时将在未来几年内不断增长。并且 JavaScript 可以用函数式风格写得更加高效。
  因为函数式编程是一种编写代码的方式，而不是一种框架或是工具，函数式的思维方式与面向对象的思维方式完全不同。摒弃旧习是最难的部分，对于一个有面向对象背景的人来说，将是一个巨大的编程范式转变。

### 1.2 什么是函数式编程？

  简单来说，函数式编程是一种强调以函数使用为主的软件开发风格。
  函数式编程的目标是使用函数来 **抽象作用在数据之上的控制流与操作** ，从而在系统中 **消除副作用并减少对状态的改变**。
  为了充分理解函数式编程，读者首先必须知道它所基于的一些基本概念：

- 声明式编程
- 纯函数
- 引用透明
- 不可变性

#### 1.2.1 函数式编程是声明式编程

  函数式编程属于 **声明式** 编程范式：这种范式会描述一系列的操作，但并不会暴露它们是如果实现的或是数据流如果穿过它们。目前，更加主流的是 **命令式** 的或 **过程式** 的编程范式。命令式编程将计算机程序视为一系列自上而下的断言，通过修改系统的各个状态来计算最终的结果。
  例如，假设你需要计算一个数组中所有数的平方，那命令式的程序应有如下的步骤：

  ```js
    var array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    for (let i = 0 ; i < array.length; i ++) {
      array[i] = Math.pow(array[i], 2);
    }
    array; // -> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
  ```

  命令式编程很具体地告诉计算机 **如何** 执行某个任务。
  而声明式编程是将程序的描述与求值分离开来的。它关注与如何用各种 **表达式** 来描述程序逻辑，而不一定要指明其控制流或状态的变化。
  上面的计算用声明式编程范式，同时结合 **lamda 表达式** 以及 **箭头函数** 的优势来将循环抽象成函数：

  ```js
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(num => Math.pow(num, 2));
    // -> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
  ```

#### 1.2.2 副作用带来的问题和纯函数

函数式编程基于一个前提，即使用纯函数构建具有不变性的程序。纯函数具有以下性质：

- 仅取决于提供的输入，而不依赖于任何函数求值期间或调用间隔时可能变化的隐藏状态和外部状态
- 不会造成超出其作用域的变化，例如修改全局对象或引用传递的参数

非纯函数会有以下的副作用：

- 改变一个全局变量、数据或数据结构
- 改变一个函数参数的原始值
- 处理用户输入
- 抛出一个异常，除非他又被当前函数捕获了
- 屏幕打印或记录日志
- 查询 HTML 文档、浏览器的 cookie 或访问数据库

函数式编程在实践上并不限制 **一切** 状态的改变。它只是提供了一个框架来帮助管理和减少可变状态，同时让你能够将纯函数从不纯的部分分离出来。

下面举一个例子，有一个短小的命令式程序，它能通过社会安全号码(SSN)找到一个同学的记录并渲染到浏览器中。

```js
function showStudent(ssn) {
  // 在对象储存中通过 SSN 查找学生。请假设这个操作现在是同步的，之后我会处理异步的情况。
  var student = db.get(ssn);
  if (student !== null) {
    // 读取函数外的 elementId 变量
    document.querySelector(`#${elementId}`).innerHTML = 
      `${student.ssn},
       ${student.firstname},
       ${student.lastname}`;
  } else {
    // 当学生信息错误时抛出异常
    throw new Error('student not found!');
  }
}

// 使用 SSN 号 444-44-4444 作为参数执行函数，结果会展示在页面上
showStudent('444-44-4444');
```

进一步分析这段代码，这个函数显然将一些副作用暴露到其作用域之外：

- 该函数为访问数据，与一个外部变量(db)进行了交互，因为该函数签名中并没有声明该参数。在任何一个时间点，这个引用可能为 null，或在调用间隔改变，从而导致完全不用的结果并破坏了程序的完整性。
- 全局变量 elementId 可能随时改变，难以控制。
- HTML 元素被直接修改了。HTML 文档(DOM)本身是一个可变的，共享的全局资源。
- 如果没有找到学生，该函数可能会抛出一个异常，这将导致整个程序的栈回退并突然结束。

一方面，上面的 showStudent 函数依赖了外部资源，使得代码很不灵活，很难维护并且难以测试。另一方面，使用纯函数，其函数签名对所描述的所有形参（输入集）都有明确的约定，使其更易于理解和使用。

再回到函数式的世界，目前可以改进以下两点：

- 将这个长函数分离成多个具有单一职责的短函数。
- 通过显式地将完成功能所需的依赖都定义为函数参数来减少副作用的数量。

首先分离屏幕显式与获取学生记录的行为。当然，与外部存储系统和 DOM 交互所造成的副作用是不可避免的，但至少可以通过将其从主逻辑中分离出来的方式使它们更易于管理。要做到这一点，需要引入一种常见的函数式编程技巧 --- **柯里化**。使用柯里化，可以允许部分地传递函数参数，以便将函数的参数减少为一个：

```js
// 函数 find 需要对象存储的引用和 ID 来查找学生
var find = curry(function(db, id) {
  var obj = db.get(id);
  if(obj === null) {
    throw new Error('Object not found!');
  }
  return obj;
});

// 将学生对象转换成用逗号分隔的字符串
var csv = function(student) {
  return `${student.ssn}, ${student.firstname}, ${student.lastname}`;
};

// 为了在屏幕上显示学生信息，这里需要 elementId 以及学生的数据
var append = curry(function(elementId, info) {
  document.querySelector(elementId).innerHTML = info;
});

var showStudent = run(
  append('#student-info'), // 部分设置 HTML 元素的 ID
  csv,
  find(db) // 部分设置查找对象为学生表
);

showStudent('444-44-4444');
```

尽管这个程序只有些许的改进，但是它开始展现出很多的优势：

- 它灵活了很多，因为现在有三个可以被重用的组件。
- 这种细粒度函数的重用是提高工作效率的一种手段，因为你可以大大减少需要主动维护的代码量。
- 声明式的代码风格提供了程序需要执行的那些高阶步骤的一个清晰视图，增强了代码的可读性。
- 更重要的是，与 HTML 对象的交互被移动到一个单独的函数中，将纯函数从不纯的行为中分离出来。柯里化以及如何管理纯与不纯的代码将在下面的文章中进一步解释。

#### 1.2.3  引用透明和可置换性

引用透明是定义一个纯函数较为正确的方式。**纯度** 在这个意义上表明一个函数的参数和返回值之前映射的纯的关系。因此，如果一个函数对于相同的输入始终产生相同的结果，那么就说它是 **引用透明** 的。

比如这段代码：

```js
var counter = 0;

function increment() {
  return ++counter;
}
```

这个函数 increment 就不是引用透明的，因为其返回值严重依赖外部变量 counter。

为了使其引用透明，需要删除其依赖的外部变量这一状态，使其成为函数签名中显式定义的参数。转换为：

```js
var increment = counter => counter + 1;
```

现在这个函数式稳定的，对于相同的输入每次都有返回相同的输出结果。

再比如计算学生的平均成绩这个例子：

```js
var input = [80, 90, 100];
var average = (arr) => divide(sum(arr), size(arr));
average(input); // => 90
```

由于函数 sum 和 size 都是引用透明的，对于如下的给定输入，很容易得地重写这个表达式：

```js
var average = divide(270, 3); // => 90
```

由于 divide 总是纯的，因此可以利用其数学符号进一步改写，所以对于当前的输入，平均值永远是 270 / 3 = 90。
整个程序如下实现：

```js
var sum = (total, current) => total + current;
var total = arr => arr.reduce(sum);
var size = arr => arr.length;
var divide = (a, b) => a / b;
var average = arr => divide(total(arr), size(arr));
average(input); // => 90
```

#### 1.2.4 储存不可变数据

**不可变数据** 是指那些被创建后不能更改的数据。JavaScript 中的所有基本类型（String、Number 等）从本质上是不可变的。但是其他对象，例如数组，都是可变的 --- 即使它们作为输入传递给另一个函数，仍然可以用过改变原有内容的方式产生副作用。考虑一个简答的数组排序代码：

```js
var sortDesc = function(arr) {
  return arr.sort(function(a, b) {
    return b - a;
  });
}
```

乍一眼看去，这段代码看起来很正常，并没有副作用。它确实如期望的那样 --- 给一个数组，返回以降序排序的相同数组。不幸的是，array.sort 函数是有状态的，会导致在排序中产生副作用，因为原始的引用被修改了。

现在，读者已经了解了函数式编程的一些基本原则，就可以简洁的描述它了：**函数式编程是指为创建不可变暖的程序，通过消除外部可见的副作用，来对纯函数的声明式的求值过程。**

强迫自己去思考纯的操作，将函数看作永不会修改数据的闭合 **功能单元**，必然可以减少这种潜在 bug 的可能性。

### 1.3 函数式编程的优点

现在来宏观地了解一下函数式能为 JavaScript 应用程序带来的好处：

- 促使将任务分解成简单的函数。
- 使用流式的调用链来处理数据。
- 通过响应式范式降低事件驱动代码的复杂性。

#### 1.3.1 鼓励复杂任务的分解

从宏观上讲，函数式编程实际上是分解（讲程序拆分为小片段）和组合（将小片段连接到一起）之间的相互作用。正是这种二元性，使得函数式程序如此模块化和高效。函数式思维的学习通常始于将特定任务分解为逻辑子任务（函数）的过程。

比如将 showStudent 函数可以拆分为 find、csv 和 append 三个小的函数片段。如果需要，这些子任务可以进一步分解，直到成为一个个简单的、相互独立的纯函数功能单元。函数式编程的模块化的概念与 **单一职责** 原则息息相关，也就是说，函数都应该拥有单一的目的。纯度和引用透明会促使你这样思考问题，因为为了将函数组合在一起，它们必须在输入和输出的形式上形成一致。

前面一直在使用的 run 函数是一个极为重要的技术的别名：**组合**。两个函数的组合是一个新的函数，它拿到一个函数的输出，并将其传递到另一个函数中。假设有两个函数 f 和 g，形式上，其组合可以如下描述：

f · g = f(g(x))

这个公式读作“f 组合上 g”，它在 g 的返回值与 f 的参数之间构建了一个松耦合的且类型安全的联系。两个函数能够组合的条件是，它们必须在参数数目以及参数类型上形成一致。但组合并不是构建流式的、模块化的代码的唯一方式。

#### 1.3.2 使用流式链来处理数据

下面通过一个例子来诠释流式链的优势。假设需要用程序计算那些选了多门课程的学生的平均成绩。已知选课数据的数组：

```js
let enrollment = [
  { enrolled: 2, grade: 100 },
  { enrolled: 2, grade: 80 },
  { enrolled: 1, grade: 89 }
];
```

命令式的实现可能是这样的：

```js
var totalGrades = 0;
var totalStudentsFound = 0;
for (var i = 0; i < enrollment.length; i ++) {
  let student = enrollment[i];
  if (student !== null) {
    if (student.enrolled > 1) {
      totalGrades = student.grade;
      totalStudentsFound ++;
    }
  }
}
var average = totalGrades / totalStudentsFound; // => 90
```

与之前一样，用函数式的思维来分解这个问题，可以发现有三个主要步骤。

- 选择合适的（选课数量大于 1 的）学生。
- 获取他们的成绩。
- 计算出他们的平均成绩。

函数链是一种 **惰性计算** 程序，这意味着当需要时才会执行。这对程序性能是有利的，因为可以避免执行可能包含一些永不会使用的内容的整个代码序列，节省宝贵的 CPU 计算周期。这有效地模拟了其他函数式语言的 **按需调用** 行为。上面的程序可以用 Lodash 缝合表征这些步骤的函数，如下述：

```js
_.chain(enrollment)
  .filter(student => student.enrolled > 1) // 选择合适的（选课数量大于 1 的）学生
  .map('grade') // 获取他们的成绩。
  .mean() // 计算出他们的平均成绩。
  .value(); // => 90
  // 调用 _.value() 会触发整个链上的所有操作 
```

当下，请与其命令式的版本进行比较，并注意如何消除变量的声明和变化，以及循环和 if-else 语句。

公平地说，这个例子略过了一些真实世界程序中典型的错误处理代码。而上文提到抛出异常是产生副作用的一个原因。幸运的是，利用一些纯函数式的设计模式，你将不需要通过牺牲函数链的描述性来为代码提供强大的错误处理逻辑。我们将在后面讨论这个话题。

#### 1.3.3 复杂异步应用中的响应